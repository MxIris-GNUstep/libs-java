/* WCClass.m: A class to be wrapped          -*-objc-*-

   Copyright (C) 2000 Free Software Foundation, Inc.

   Author:  Nicola Pero <nicola@brainstorm.co.uk>
   Date: August 2000
   
   This file is part of JIGS, the GNUstep Java Interface.
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */

#include "WCClass.h"
#include "WCLibrary.h"
#include "WCMethod.h"
#include "WCHeaderParser.h"

@implementation WCClass

+ (id) newWithDictionary: (NSDictionary *)dict
{
  return [[self alloc] initWithDictionary: dict];
}

- (id) initWithDictionary: (NSDictionary *)dict
{
  NSDictionary *dictionary;
  NSArray *array;
  NSString *name;

  name = [dict objectForKey: @"java name"];
  ASSIGN (javaName, name);

  name = [dict objectForKey: @"objective-c name"];
  if (name != nil)
    {
      ASSIGN (objcName, name);
    }
  else
    {
      ASSIGN (objcName, [self shortJavaName]);
    }

  array = [dict objectForKey: @"class methods"];
  ASSIGN (classMethods, array);

  array = [dict objectForKey: @"initializers"];
  ASSIGN (initializers, array);

  array = [dict objectForKey: @"instance methods"];
  ASSIGN (instanceMethods, array);

  dictionary = [dict objectForKey: @"method name mapping"];
  ASSIGN (methodNameMapping, dictionary);

  array = [dict objectForKey: @"prerequisite libraries"];
  ASSIGN (prerequisiteLibraries, array);
  // TODO: Class specific configurations read here
  return self;
}

- (NSString *)objcName
{
  return objcName;
}

- (NSString *)javaName
{
  return javaName;
}

- (NSString *)jniName
{
  // FIXME: Better conversion java name->jni name
  return [javaName stringByReplacingString: @"." withString: @"_"];
}

- (NSString *)packageName
{
  NSString *packageName;
      
  packageName = [javaName stringByDeletingPathExtension];
      
  if (([packageName isEqualToString: @""] == NO) 
      && ([packageName isEqualToString: javaName] == NO))
    {
      return packageName;
    }
  else
    {
      return nil;
    }  
}

- (NSString *)shortJavaName
{
  NSString *shortJavaName;
      
  shortJavaName = [javaName pathExtension];
      
  if ([shortJavaName isEqual: @""] == NO)
    {
      return shortJavaName;
    }
  else
    {
      return javaName;
    }
}

- (NSString *)javaMethodForObjcMethod: (NSString *)methodName
{
  NSString *output;

  output = [methodNameMapping objectForKey: methodName];
  if (output != nil)
    {
      return output;
    }
  
  return [WCLibrary javaMethodForObjcMethod: methodName];
}

- (NSArray *)prerequisiteLibraries
{
  NSMutableArray *arrayOne;
  NSArray *arrayTwo;
  NSObject *object;
  int i, count;

  arrayOne = [[WCLibrary prerequisiteLibraries] mutableCopy];
  arrayTwo = prerequisiteLibraries;

  if (arrayOne == nil)
    {
      arrayOne = [NSMutableArray new];
    }

  AUTORELEASE (arrayOne);

  /* Now merge the two; WCLibrary ones come before and we don't 
     want replicates. */
  count = [arrayTwo count];
  for (i = 0; i < count; i++)
    {
      object = [arrayTwo objectAtIndex: i];
      if ([arrayOne containsObject: object] == NO)
	{
	  [arrayOne addObject: object];
	}
    }

  return arrayOne;
}

- (void) outputWrappers
{
  NSString *path;
  NSMutableString *objcOutput;
  NSMutableString *javaOutput;
  NSString *declaration;
  WCMethod *method;
  int i, count;
  WCHeaderParser *wc;
  NSArray *libraries;

  wc = [WCLibrary headerParser];
  
  javaOutput = [NSMutableString stringWithString: @"/* Wrapper for class "];
  [javaOutput appendString: objcName];
  [javaOutput appendString: @", generated by JIGS Wrap Creator\n"];
  [javaOutput appendString: @"   This file is automatically generated, "];
  [javaOutput appendString: @"do not edit!\n"];
  [javaOutput appendString: @"*/\n"];

  if ([self packageName] != nil)
    {
      [javaOutput appendFormat: @"package %@;\n\n", [self packageName]];
    }
  
  [javaOutput appendString: @"import gnu.gnustep.java.JIGS;\n"];
  [javaOutput appendString: @"import gnu.gnustep.base.*;\n\n"];
  // TODO: Additional imports ?

  [javaOutput appendString: @"public class "];
  [javaOutput appendString: [self shortJavaName]];
  [javaOutput appendString: @" extends "];
  [javaOutput appendString: [wc getSuperclassOfClass: objcName]];
  [javaOutput appendString: @"\n{\n"];
  [javaOutput appendString: @"\n  static\n  {"];

  libraries = [self prerequisiteLibraries];
  count = [libraries count];
  for (i = 0; i < count; i++)
    {
      [javaOutput appendString: @"\n    JIGS.loadLibrary (\""];
      [javaOutput appendString: (NSString *)[libraries objectAtIndex: i]];
      [javaOutput appendString: @".A\");"];      
    }

  [javaOutput appendString: @"\n    JIGS.loadLibrary (\""];
  [javaOutput appendString: [WCLibrary shortLibraryName]];
  [javaOutput appendString: @".A\");\n"];
  [javaOutput appendString: @"  }\n\n  protected "];
  [javaOutput appendString: [self shortJavaName]];
  [javaOutput appendString: @" (GSInitializationType type)\n  {\n     "
	      @"super (type);\n  }\n\n"];

  objcOutput = [NSMutableString stringWithString: @"/* Wrapper for class "];
  [objcOutput appendString: objcName];
  [objcOutput appendString: @", generated by JIGS Wrap Creator\n"];
  [objcOutput appendString: @"   This file is automatically generated, do not edit!\n"];
  [objcOutput appendString: @"*/\n"];
  
  [objcOutput appendString: @"#include <Foundation/Foundation.h>\n"];
  [objcOutput appendString: @"#include <jni.h>\n"];
  [objcOutput appendString: @"#include <java/JIGS.h>\n"];
  // FIXME: #include "./SimpleGUI.h"
  [objcOutput appendFormat: @"#include \"%@\"\n", [WCLibrary libraryHeader]];
  [objcOutput appendString: @"\n"];

  /* Now the methods */
  
  if (initializers != nil)
    {
      [javaOutput appendString: @"  /* Constructors */\n"];
      [javaOutput appendString: @"\n"];
      [objcOutput appendString: @"/* Initializers */\n"];
      [objcOutput appendString: @"\n"];

      count = [initializers count];

      for (i = 0; i < count; i++)
	{
	  if ([WCLibrary verboseOutput] == YES)
	    {
	      printf ("Wrapping initializer %s\n", 
		      [[initializers objectAtIndex: i] cString]);
	    }
	  declaration = [wc declarationOfMethod: [initializers objectAtIndex: i]
			    isClassMethod: NO];
	  method = [WCMethod newWithObjcMethodDeclaration: declaration
			     class: self
			     isConstructor: YES];
	  [javaOutput appendString: [method outputJavaWrapper]];
	  [javaOutput appendString: @"\n"];
	  [objcOutput appendString: [method outputObjcWrapper]];
	  [objcOutput appendString: @"\n"];
	}
    }

  if (classMethods != nil)
    {

      [javaOutput appendString: @"  /* Static Methods */\n"];
      [javaOutput appendString: @"\n"];
      [objcOutput appendString: @"/* Class methods */\n"];
      [objcOutput appendString: @"\n"];
      
      count = [classMethods count];
      
      for (i = 0; i < count; i++)
	{
	  if ([WCLibrary verboseOutput] == YES)
	    {
	      printf ("Wrapping class method %s\n", 
		      [[classMethods objectAtIndex: i] cString]);
	    }
	  declaration = [wc declarationOfMethod: [classMethods objectAtIndex: i]
			    isClassMethod: YES];
	  method = [WCMethod newWithObjcMethodDeclaration: declaration
			     class: self
			     isConstructor: NO];
	  [javaOutput appendString: [method outputJavaWrapper]];
	  [javaOutput appendString: @"\n"];
	  [objcOutput appendString: [method outputObjcWrapper]];
	  [objcOutput appendString: @"\n"];
	}
    }

  if (instanceMethods != nil)
    {
      [javaOutput appendString: @"  /* Instance Methods */\n"];
      [javaOutput appendString: @"\n"];
      [objcOutput appendString: @"/* Instance Methods */\n"];
      [objcOutput appendString: @"\n"];
      
      count = [instanceMethods count];
      
      for (i = 0; i < count; i++)
	{
	  if ([WCLibrary verboseOutput] == YES)
	    {
	      printf ("Wrapping instance method %s\n", 
		      [[instanceMethods objectAtIndex: i] cString]);
	    }
	  declaration = [wc declarationOfMethod: [instanceMethods objectAtIndex: i]
			    isClassMethod: NO];
	  method = [WCMethod newWithObjcMethodDeclaration: declaration
			     class: self
			     isConstructor: NO];
	  [javaOutput appendString: [method outputJavaWrapper]];
	  [javaOutput appendString: @"\n"];
	  [objcOutput appendString: [method outputObjcWrapper]];
	  [objcOutput appendString: @"\n"];
	}
    }

  [javaOutput appendString: @"}\n/* END OF FILE */\n"];
  [objcOutput appendString: @"/* END OF FILE */\n"];  
  
  /* Create directories for Java file */
  [WCLibrary createJavaDirectoryForClass: javaName];
  /* Write the Java Code to file */
  path = [WCLibrary javaWrapperFileForClass: javaName];
  if ([javaOutput writeToFile: path  atomically: YES] == NO)
    {
      NSLog (@"Error - could not write to file %@", path);
    }
  /* Write Objc Code to file */
  path = [WCLibrary objcWrapperFileForClass: objcName];
  if ([objcOutput writeToFile: path  atomically: YES] == NO)
    {
      NSLog (@"Error - could not write to file %@", path);
    }
}

@end



